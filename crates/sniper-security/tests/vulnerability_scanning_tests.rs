//! Unit tests for the vulnerability scanning module
//!
//! This file contains comprehensive unit tests for the vulnerability scanning functionality.

use sniper_security::vulnerability_scanning::*;
use std::time::Duration;

/// Test vulnerability scanner creation
#[tokio::test]
async fn test_vulnerability_scanner_creation() {
    let config = VulnerabilityScanConfig::default();
    let scanner = VulnerabilityScanner::new(config.clone());

    assert_eq!(
        scanner.config().cargo_audit_enabled,
        config.cargo_audit_enabled
    );
    assert_eq!(scanner.config().fail_threshold, config.fail_threshold);
}

/// Test vulnerability scan execution
#[tokio::test]
async fn test_vulnerability_scan_execution() {
    let config = VulnerabilityScanConfig {
        cargo_audit_enabled: true,
        cargo_deny_enabled: true,
        os_vulnerability_scan: true,
        container_scan_enabled: true,
        fail_threshold: SeverityLevel::High,
    };

    let scanner = VulnerabilityScanner::new(config);
    let results = scanner.run_vulnerability_scan().await.unwrap();

    assert!(results.duration > Duration::from_millis(0));
    assert!(results.cargo_audit_results.is_some());
    assert!(results.cargo_deny_results.is_some());
    assert!(results.os_vulnerability_results.is_some());
    assert!(results.container_scan_results.is_some());
    assert!(results.security_score <= 100);
}

/// Test security score calculation
#[tokio::test]
async fn test_security_score_calculation() {
    let config = VulnerabilityScanConfig::default();
    let scanner = VulnerabilityScanner::new(config);

    let mut vulnerability_counts = std::collections::HashMap::new();
    vulnerability_counts.insert(SeverityLevel::Low, 0);
    vulnerability_counts.insert(SeverityLevel::Medium, 0);
    vulnerability_counts.insert(SeverityLevel::High, 0);
    vulnerability_counts.insert(SeverityLevel::Critical, 0);

    let score = scanner.calculate_security_score(&vulnerability_counts);
    assert_eq!(score, 100);
}

/// Test fail threshold check
#[tokio::test]
async fn test_fail_threshold_check() {
    let config = VulnerabilityScanConfig {
        fail_threshold: SeverityLevel::High,
        ..Default::default()
    };
    let scanner = VulnerabilityScanner::new(config);

    let mut vulnerability_counts = std::collections::HashMap::new();
    vulnerability_counts.insert(SeverityLevel::Low, 5);
    vulnerability_counts.insert(SeverityLevel::Medium, 3);
    vulnerability_counts.insert(SeverityLevel::High, 0);
    vulnerability_counts.insert(SeverityLevel::Critical, 0);

    let results = VulnerabilityScanResults {
        config: VulnerabilityScanConfig::default(),
        duration: Duration::from_secs(10),
        cargo_audit_results: None,
        cargo_deny_results: None,
        os_vulnerability_results: None,
        container_scan_results: None,
        vulnerability_counts,
        security_score: 85,
    };

    // Should not fail because no high or critical vulnerabilities
    assert!(!scanner.should_fail_scan(&results));
}

/// Test severity level ordering
#[test]
fn test_severity_level_ordering() {
    assert!(SeverityLevel::Low < SeverityLevel::Medium);
    assert!(SeverityLevel::Medium < SeverityLevel::High);
    assert!(SeverityLevel::High < SeverityLevel::Critical);

    let mut levels = vec![
        SeverityLevel::High,
        SeverityLevel::Low,
        SeverityLevel::Critical,
        SeverityLevel::Medium,
    ];

    levels.sort();

    assert_eq!(levels[0], SeverityLevel::Low);
    assert_eq!(levels[1], SeverityLevel::Medium);
    assert_eq!(levels[2], SeverityLevel::High);
    assert_eq!(levels[3], SeverityLevel::Critical);
}
