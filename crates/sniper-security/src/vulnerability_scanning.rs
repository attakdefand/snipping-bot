//! Vulnerability scanning module for the sniper bot.
//!
//! This module implements dependency vulnerability scanning functionality
//! to ensure all dependencies are secure and up-to-date.

use anyhow::Result;
use std::collections::HashMap;
use std::time::Duration;
use tracing::{error, info};

/// Vulnerability scan configuration
#[derive(Debug, Clone)]
pub struct VulnerabilityScanConfig {
    /// Enable/disable cargo audit scanning
    pub cargo_audit_enabled: bool,
    /// Enable/disable cargo deny scanning
    pub cargo_deny_enabled: bool,
    /// Enable/disable OS vulnerability scanning
    pub os_vulnerability_scan: bool,
    /// Enable/disable container image scanning
    pub container_scan_enabled: bool,
    /// Threshold for failing the scan (critical, high, medium, low)
    pub fail_threshold: SeverityLevel,
}

impl Default for VulnerabilityScanConfig {
    fn default() -> Self {
        Self {
            cargo_audit_enabled: true,
            cargo_deny_enabled: true,
            os_vulnerability_scan: true,
            container_scan_enabled: true,
            fail_threshold: SeverityLevel::High,
        }
    }
}

/// Severity levels for vulnerabilities
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum SeverityLevel {
    Low,
    Medium,
    High,
    Critical,
}

/// Vulnerability scan results
#[derive(Debug, Clone)]
pub struct VulnerabilityScanResults {
    /// Configuration used for the scan
    pub config: VulnerabilityScanConfig,
    /// Duration of the scan
    pub duration: Duration,
    /// Cargo audit results
    pub cargo_audit_results: Option<CargoAuditResults>,
    /// Cargo deny results
    pub cargo_deny_results: Option<CargoDenyResults>,
    /// OS vulnerability results
    pub os_vulnerability_results: Option<OsVulnerabilityResults>,
    /// Container scan results
    pub container_scan_results: Option<ContainerScanResults>,
    /// Overall vulnerability count by severity
    pub vulnerability_counts: HashMap<SeverityLevel, usize>,
    /// Overall security score (0-100)
    pub security_score: u8,
}

/// Cargo audit results
#[derive(Debug, Clone)]
pub struct CargoAuditResults {
    /// Number of vulnerabilities found
    pub vulnerabilities_found: usize,
    /// Vulnerabilities by severity
    pub vulnerabilities: HashMap<SeverityLevel, Vec<Vulnerability>>,
    /// Advisory database update status
    pub advisory_db_updated: bool,
}

/// Cargo deny results
#[derive(Debug, Clone)]
pub struct CargoDenyResults {
    /// Number of banned dependencies
    pub banned_dependencies: usize,
    /// Number of denied licenses
    pub denied_licenses: usize,
    /// Duplicate dependency warnings
    pub duplicate_warnings: usize,
}

/// OS vulnerability results
#[derive(Debug, Clone)]
pub struct OsVulnerabilityResults {
    /// Number of OS vulnerabilities found
    pub vulnerabilities_found: usize,
    /// Critical vulnerabilities
    pub critical_vulnerabilities: Vec<String>,
}

/// Container scan results
#[derive(Debug, Clone)]
pub struct ContainerScanResults {
    /// Number of container vulnerabilities found
    pub vulnerabilities_found: usize,
    /// Image name scanned
    pub image_name: String,
}

/// Vulnerability information
#[derive(Debug, Clone)]
pub struct Vulnerability {
    /// Vulnerability ID
    pub id: String,
    /// Vulnerability title
    pub title: String,
    /// Vulnerability description
    pub description: String,
    /// Severity level
    pub severity: SeverityLevel,
    /// Affected package
    pub package: String,
    /// Version information
    pub version_info: VersionInfo,
}

/// Version information for a vulnerability
#[derive(Debug, Clone)]
pub struct VersionInfo {
    /// Installed version
    pub installed: String,
    /// Patched version
    pub patched: Option<String>,
}

/// Vulnerability scanner
pub struct VulnerabilityScanner {
    config: VulnerabilityScanConfig,
}

impl VulnerabilityScanner {
    /// Create a new vulnerability scanner
    pub fn new(config: VulnerabilityScanConfig) -> Self {
        Self { config }
    }

    /// Get the configuration
    pub fn config(&self) -> &VulnerabilityScanConfig {
        &self.config
    }

    /// Calculate security score based on vulnerability counts
    pub fn calculate_security_score(
        &self,
        vulnerability_counts: &HashMap<SeverityLevel, usize>,
    ) -> u8 {
        // Weighted scoring: Critical=10, High=5, Medium=2, Low=1
        let critical_count = vulnerability_counts
            .get(&SeverityLevel::Critical)
            .unwrap_or(&0);
        let high_count = vulnerability_counts.get(&SeverityLevel::High).unwrap_or(&0);
        let medium_count = vulnerability_counts
            .get(&SeverityLevel::Medium)
            .unwrap_or(&0);
        let low_count = vulnerability_counts.get(&SeverityLevel::Low).unwrap_or(&0);

        let weighted_score =
            (critical_count * 10 + high_count * 5 + medium_count * 2 + low_count * 1) as f64;

        // Convert to 0-100 scale (assuming max possible score of 100 for demonstration)
        let max_score = 100.0;
        let score = if weighted_score > max_score {
            0
        } else {
            (max_score - weighted_score) as u8
        };

        score
    }

    /// Determine if the scan should fail based on configured threshold
    pub fn should_fail_scan(&self, results: &VulnerabilityScanResults) -> bool {
        match self.config.fail_threshold {
            SeverityLevel::Low => {
                results
                    .vulnerability_counts
                    .get(&SeverityLevel::Low)
                    .unwrap_or(&0)
                    > &0
                    || results
                        .vulnerability_counts
                        .get(&SeverityLevel::Medium)
                        .unwrap_or(&0)
                        > &0
                    || results
                        .vulnerability_counts
                        .get(&SeverityLevel::High)
                        .unwrap_or(&0)
                        > &0
                    || results
                        .vulnerability_counts
                        .get(&SeverityLevel::Critical)
                        .unwrap_or(&0)
                        > &0
            }
            SeverityLevel::Medium => {
                results
                    .vulnerability_counts
                    .get(&SeverityLevel::Medium)
                    .unwrap_or(&0)
                    > &0
                    || results
                        .vulnerability_counts
                        .get(&SeverityLevel::High)
                        .unwrap_or(&0)
                        > &0
                    || results
                        .vulnerability_counts
                        .get(&SeverityLevel::Critical)
                        .unwrap_or(&0)
                        > &0
            }
            SeverityLevel::High => {
                results
                    .vulnerability_counts
                    .get(&SeverityLevel::High)
                    .unwrap_or(&0)
                    > &0
                    || results
                        .vulnerability_counts
                        .get(&SeverityLevel::Critical)
                        .unwrap_or(&0)
                        > &0
            }
            SeverityLevel::Critical => {
                results
                    .vulnerability_counts
                    .get(&SeverityLevel::Critical)
                    .unwrap_or(&0)
                    > &0
            }
        }
    }

    /// Run comprehensive vulnerability scanning
    pub async fn run_vulnerability_scan(&self) -> Result<VulnerabilityScanResults> {
        info!("Starting vulnerability scan");

        let start_time = std::time::Instant::now();
        let mut vulnerability_counts = HashMap::new();

        // Initialize counts
        vulnerability_counts.insert(SeverityLevel::Low, 0);
        vulnerability_counts.insert(SeverityLevel::Medium, 0);
        vulnerability_counts.insert(SeverityLevel::High, 0);
        vulnerability_counts.insert(SeverityLevel::Critical, 0);

        let mut cargo_audit_results = None;
        let mut cargo_deny_results = None;
        let mut os_vulnerability_results = None;
        let mut container_scan_results = None;

        // Run cargo audit if enabled
        if self.config.cargo_audit_enabled {
            cargo_audit_results = Some(self.run_cargo_audit().await?);
            // Update vulnerability counts
            for (severity, vulnerabilities) in
                &cargo_audit_results.as_ref().unwrap().vulnerabilities
            {
                *vulnerability_counts.get_mut(severity).unwrap() += vulnerabilities.len();
            }
        }

        // Run cargo deny if enabled
        if self.config.cargo_deny_enabled {
            cargo_deny_results = Some(self.run_cargo_deny().await?);
        }

        // Run OS vulnerability scan if enabled
        if self.config.os_vulnerability_scan {
            os_vulnerability_results = Some(self.run_os_vulnerability_scan().await?);
            vulnerability_counts.insert(
                SeverityLevel::Critical,
                vulnerability_counts.get(&SeverityLevel::Critical).unwrap()
                    + os_vulnerability_results
                        .as_ref()
                        .unwrap()
                        .critical_vulnerabilities
                        .len(),
            );
        }

        // Run container scan if enabled
        if self.config.container_scan_enabled {
            container_scan_results = Some(self.run_container_scan().await?);
            vulnerability_counts.insert(
                SeverityLevel::High,
                vulnerability_counts.get(&SeverityLevel::High).unwrap()
                    + container_scan_results
                        .as_ref()
                        .unwrap()
                        .vulnerabilities_found,
            );
        }

        let duration = start_time.elapsed();

        // Calculate security score
        let security_score = self.calculate_security_score(&vulnerability_counts);

        let results = VulnerabilityScanResults {
            config: self.config.clone(),
            duration,
            cargo_audit_results,
            cargo_deny_results,
            os_vulnerability_results,
            container_scan_results,
            vulnerability_counts,
            security_score,
        };

        info!(
            "Vulnerability scan completed. Security score: {}/100",
            results.security_score
        );

        // Check if we should fail based on threshold
        if self.should_fail_scan(&results) {
            error!("Vulnerability scan failed due to vulnerabilities exceeding threshold");
        }

        Ok(results)
    }

    /// Run cargo audit
    async fn run_cargo_audit(&self) -> Result<CargoAuditResults> {
        info!("Running cargo audit");

        // In a real implementation, this would call `cargo audit`
        // For now, we'll simulate the results

        let mut vulnerabilities = HashMap::new();
        vulnerabilities.insert(SeverityLevel::Low, vec![]);
        vulnerabilities.insert(SeverityLevel::Medium, vec![]);
        vulnerabilities.insert(SeverityLevel::High, vec![]);
        vulnerabilities.insert(SeverityLevel::Critical, vec![]);

        let results = CargoAuditResults {
            vulnerabilities_found: 0,
            vulnerabilities,
            advisory_db_updated: true,
        };

        Ok(results)
    }

    /// Run cargo deny
    async fn run_cargo_deny(&self) -> Result<CargoDenyResults> {
        info!("Running cargo deny");

        // In a real implementation, this would call `cargo deny check`
        // For now, we'll simulate the results

        let results = CargoDenyResults {
            banned_dependencies: 0,
            denied_licenses: 0,
            duplicate_warnings: 0,
        };

        Ok(results)
    }

    /// Run OS vulnerability scan
    async fn run_os_vulnerability_scan(&self) -> Result<OsVulnerabilityResults> {
        info!("Running OS vulnerability scan");

        // In a real implementation, this would scan the OS for vulnerabilities
        // For now, we'll simulate the results

        let results = OsVulnerabilityResults {
            vulnerabilities_found: 0,
            critical_vulnerabilities: vec![],
        };

        Ok(results)
    }

    /// Run container scan
    async fn run_container_scan(&self) -> Result<ContainerScanResults> {
        info!("Running container scan");

        // In a real implementation, this would scan container images for vulnerabilities
        // For now, we'll simulate the results

        let results = ContainerScanResults {
            vulnerabilities_found: 0,
            image_name: "sniper-bot:latest".to_string(),
        };

        Ok(results)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_vulnerability_scanner_creation() {
        let config = VulnerabilityScanConfig::default();
        let scanner = VulnerabilityScanner::new(config.clone());

        assert_eq!(
            scanner.config.cargo_audit_enabled,
            config.cargo_audit_enabled
        );
        assert_eq!(scanner.config.fail_threshold, config.fail_threshold);
    }

    #[tokio::test]
    async fn test_vulnerability_scan_execution() {
        let config = VulnerabilityScanConfig {
            cargo_audit_enabled: true,
            cargo_deny_enabled: true,
            os_vulnerability_scan: true,
            container_scan_enabled: true,
            fail_threshold: SeverityLevel::High,
        };

        let scanner = VulnerabilityScanner::new(config);
        let results = scanner.run_vulnerability_scan().await.unwrap();

        assert!(results.duration > Duration::from_millis(0));
        assert!(results.cargo_audit_results.is_some());
        assert!(results.cargo_deny_results.is_some());
        assert!(results.os_vulnerability_results.is_some());
        assert!(results.container_scan_results.is_some());
    }

    #[tokio::test]
    async fn test_security_score_calculation() {
        let config = VulnerabilityScanConfig::default();
        let scanner = VulnerabilityScanner::new(config);

        let mut vulnerability_counts = HashMap::new();
        vulnerability_counts.insert(SeverityLevel::Low, 0);
        vulnerability_counts.insert(SeverityLevel::Medium, 0);
        vulnerability_counts.insert(SeverityLevel::High, 0);
        vulnerability_counts.insert(SeverityLevel::Critical, 0);

        let score = scanner.calculate_security_score(&vulnerability_counts);
        assert_eq!(score, 100);
    }

    #[tokio::test]
    async fn test_fail_threshold_check() {
        let config = VulnerabilityScanConfig {
            fail_threshold: SeverityLevel::High,
            ..Default::default()
        };
        let scanner = VulnerabilityScanner::new(config);

        let mut vulnerability_counts = HashMap::new();
        vulnerability_counts.insert(SeverityLevel::Low, 5);
        vulnerability_counts.insert(SeverityLevel::Medium, 3);
        vulnerability_counts.insert(SeverityLevel::High, 0);
        vulnerability_counts.insert(SeverityLevel::Critical, 0);

        let results = VulnerabilityScanResults {
            config: VulnerabilityScanConfig::default(),
            duration: Duration::from_secs(10),
            cargo_audit_results: None,
            cargo_deny_results: None,
            os_vulnerability_results: None,
            container_scan_results: None,
            vulnerability_counts,
            security_score: 85,
        };

        // Should not fail because no high or critical vulnerabilities
        assert!(!scanner.should_fail_scan(&results));
    }
}
